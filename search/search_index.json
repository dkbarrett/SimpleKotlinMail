{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to SimpleKotlinMail \u00b6 SimpleKotlinMail is a Kotlin Email API - coroutine based, easy to use and modern! You can use it for both clientside and serverside projects, meaning you can send and receive emails. Coroutines \u00b6 Send emails without blocking the current thread. Easy to use \u00b6 Create emails, mailers and SMTP servers with the help of intuitive Kotlin builders. Modern \u00b6 SimpleKotlinMail hides unnecessary and overly complicated parts of the mail protocol from you. Additionally, the API is typesafe. Get Started \u00b6 Follow the setup guide to get started quickly. Links \u00b6 GitHub repository","title":"Home"},{"location":"#welcome-to-simplekotlinmail","text":"SimpleKotlinMail is a Kotlin Email API - coroutine based, easy to use and modern! You can use it for both clientside and serverside projects, meaning you can send and receive emails.","title":"Welcome to SimpleKotlinMail"},{"location":"#coroutines","text":"Send emails without blocking the current thread.","title":"Coroutines"},{"location":"#easy-to-use","text":"Create emails, mailers and SMTP servers with the help of intuitive Kotlin builders.","title":"Easy to use"},{"location":"#modern","text":"SimpleKotlinMail hides unnecessary and overly complicated parts of the mail protocol from you. Additionally, the API is typesafe.","title":"Modern"},{"location":"#get-started","text":"Follow the setup guide to get started quickly.","title":"Get Started"},{"location":"#links","text":"GitHub repository","title":"Links"},{"location":"client/","text":"Client \u00b6 Mailer \u00b6 A mailer instance is connected to an SMTP server capable of sending emails (e.g. Postfix , paid services or Gmail). For a list of free SMTP servers have a look into this list by mailtrap . If you want to configure a send-only postfix server, read this tutorial . Create a Mailer \u00b6 val mailer = mailerBuilder ( host = \"your_hostname\" , port = 25 ) Set the global default Mailer \u00b6 The default mailer will be used for sending emails if no specific mailer is passed as a parameter. MailerManager . defaultMailer = mailer Shutdown all Mailers \u00b6 The mailer instances keep your program alive. In order to exit your program safely, you have to shut down the mailer instances. MailerManager . shutdownMailers () Send emails \u00b6 Easily send your previously built emails . Using coroutines (Asynchronously) \u00b6 This approach allows you to send emails without blocking the current thread. These methods only work within a CoroutineScope . email . send () // using the defult Mailer instance // or email . send ( mailer ) Suspend until completion \u00b6 The send function returns a Job , therefore you can just join it. email . send (). join () This can thrown an exception of the delivery failed, you can handle that like this: kotlin . runCatching { email . send (). join () } . onFailure { it . printStackTrace () } . onSuccess { println ( \"I just sent an email!\" ) } Synchronously \u00b6 If you need to send your emails synchronously for some reason, you can do that. This function will throw an exception if the action fails, otherwise (on success) it will just pass. email . sendSync () // using the defult Mailer instance // or email . sendSync ( mailer )","title":"Client (send)"},{"location":"client/#client","text":"","title":"Client"},{"location":"client/#mailer","text":"A mailer instance is connected to an SMTP server capable of sending emails (e.g. Postfix , paid services or Gmail). For a list of free SMTP servers have a look into this list by mailtrap . If you want to configure a send-only postfix server, read this tutorial .","title":"Mailer"},{"location":"client/#create-a-mailer","text":"val mailer = mailerBuilder ( host = \"your_hostname\" , port = 25 )","title":"Create a Mailer"},{"location":"client/#set-the-global-default-mailer","text":"The default mailer will be used for sending emails if no specific mailer is passed as a parameter. MailerManager . defaultMailer = mailer","title":"Set the global default Mailer"},{"location":"client/#shutdown-all-mailers","text":"The mailer instances keep your program alive. In order to exit your program safely, you have to shut down the mailer instances. MailerManager . shutdownMailers ()","title":"Shutdown all Mailers"},{"location":"client/#send-emails","text":"Easily send your previously built emails .","title":"Send emails"},{"location":"convert/","text":"Convert \u00b6 It is easy to convert between different email representations. To an email object \u00b6 EML String to Email string . toEmail () MimeMessage to Email mimeMessage . email From an email object \u00b6 Email to MimeMessage email . mimeMessage Email to EML String email . eml","title":"Convert"},{"location":"convert/#convert","text":"It is easy to convert between different email representations.","title":"Convert"},{"location":"convert/#to-an-email-object","text":"EML String to Email string . toEmail () MimeMessage to Email mimeMessage . email","title":"To an email object"},{"location":"convert/#from-an-email-object","text":"Email to MimeMessage email . mimeMessage Email to EML String email . eml","title":"From an email object"},{"location":"core/","text":"Email API \u00b6 Create an email \u00b6 You can create an email using the emailBuilder function. Inside an email builder you set everything you need. val email = emailBuilder { from ( \"foo@bar.com\" ) to ( \"info@example.org\" ) withSubject ( \"Important question\" ) withPlainText ( \"Hey, how are you today?\" ) // and much more } A built email object is immutable. Send that email \u00b6 Go to the client page . Copy an email \u00b6 If you don't want to start blank with your email builder, you can copy another email and change it to your liking. val copiedEmail = email . copy { // modify the email } Forward an email \u00b6 val forwardEmail = email . forward ( from = \"forwardaddress@example.org\" ) { prependText ( \"This is a forwarded message.\" ) } Reply to an email \u00b6 val replyEmail = email . reply ( from = \"replyaddress@example.org\" , toAll = false ) { prependText ( \"This is a reply message.\" ) }","title":"Email API"},{"location":"core/#email-api","text":"","title":"Email API"},{"location":"core/#create-an-email","text":"You can create an email using the emailBuilder function. Inside an email builder you set everything you need. val email = emailBuilder { from ( \"foo@bar.com\" ) to ( \"info@example.org\" ) withSubject ( \"Important question\" ) withPlainText ( \"Hey, how are you today?\" ) // and much more } A built email object is immutable.","title":"Create an email"},{"location":"core/#send-that-email","text":"Go to the client page .","title":"Send that email"},{"location":"core/#copy-an-email","text":"If you don't want to start blank with your email builder, you can copy another email and change it to your liking. val copiedEmail = email . copy { // modify the email }","title":"Copy an email"},{"location":"core/#forward-an-email","text":"val forwardEmail = email . forward ( from = \"forwardaddress@example.org\" ) { prependText ( \"This is a forwarded message.\" ) }","title":"Forward an email"},{"location":"core/#reply-to-an-email","text":"val replyEmail = email . reply ( from = \"replyaddress@example.org\" , toAll = false ) { prependText ( \"This is a reply message.\" ) }","title":"Reply to an email"},{"location":"html/","text":"HTML \u00b6 SimpleKotlinMail provides a convenient way for setting the HTML content of a message. Instead of just passing in the HTML text, you can use the HTML DSL of kotlinx.html to create the HTML content. Set HTML content \u00b6 Inside your email builder, use the withHTML function. emailBuilder { withHTML { body { h1 { + \"Really important question:\" } p { + \"Hey, how are you today?\" } } } } What are the advantages of using kotlinx.html? \u00b6 In the above example, there isn't any real advantage apart from the better readability. But as soon as you want to customize the messages, for example for a specific user, kotlinx.html shows its full power. Let's say that we want to greet the user with his name. Additionally, we want to list the items he bought: val username = \"foo\" val itemsBought = listOf ( \"banana\" , \"apple\" ) emailBuilder { withHTML { body { h1 { + \"We have received your order.\" } p { + \"Thanks for shopping with us $ username !\" } p { + \"You have bought the following items:\" } ul { for ( item in itemsBought ) li { + item } } } } } Here kotlinx.html allows us to use the existing data we have ( username and itemsBought ) without the need for an additional templating language.","title":"Kotlin HTML DSL"},{"location":"html/#html","text":"SimpleKotlinMail provides a convenient way for setting the HTML content of a message. Instead of just passing in the HTML text, you can use the HTML DSL of kotlinx.html to create the HTML content.","title":"HTML"},{"location":"html/#set-html-content","text":"Inside your email builder, use the withHTML function. emailBuilder { withHTML { body { h1 { + \"Really important question:\" } p { + \"Hey, how are you today?\" } } } }","title":"Set HTML content"},{"location":"html/#what-are-the-advantages-of-using-kotlinxhtml","text":"In the above example, there isn't any real advantage apart from the better readability. But as soon as you want to customize the messages, for example for a specific user, kotlinx.html shows its full power. Let's say that we want to greet the user with his name. Additionally, we want to list the items he bought: val username = \"foo\" val itemsBought = listOf ( \"banana\" , \"apple\" ) emailBuilder { withHTML { body { h1 { + \"We have received your order.\" } p { + \"Thanks for shopping with us $ username !\" } p { + \"You have bought the following items:\" } ul { for ( item in itemsBought ) li { + item } } } } } Here kotlinx.html allows us to use the existing data we have ( username and itemsBought ) without the need for an additional templating language.","title":"What are the advantages of using kotlinx.html?"},{"location":"server/","text":"SMTP Server \u00b6 This SMTP server can be used to receive emails. Setup \u00b6 To set up a new SMTP server you can use the smtpServer function. val smtpServer = smtpServer ( port = 25 ) { // access the SMTP server builder in here (more information below) } Now you can start the SMTPServer // this function does not block, // but it keeps the current thread alive until you call stop() smtpServer . start () It is good practice to stop the SMTPServer smtpServer . stop () The following code samples all are inside an SMTP server builder. Optional Configuration \u00b6 Configuration variables \u00b6 Inside the SMTP server builder, you have access to the following configuration variables: Option Description maxRecipients The maximum amount of recipients the server accepts per message. default = 1000 maxConnections The maximum amount of connections the server allows at once. default = 1000 prefferedMaxMessageSize The maximum size of a message. This won't be enforced, this is just an information for the connected client. default = null (no limit) connectionTimeout The timeout for waiting for data on a connection. default = 1 to TimeUnit.MINUTES (1 minute) The best way to set this is the following connectionTimeout = 2 to TimeUnit . MINUTES TLS (Secure connections) \u00b6 Go to the dedicated TLS page for more details. Listeners \u00b6 With listeners, you can receive and process emails . Commands \u00b6 Mail (easiest) \u00b6 Listen to the DATA command (called last, therefore has the most information): mailListener { // get envelope data it . envelopeFrom it . recipients // get the email it . email // optional response it . respondText ( \"OK message received\" ) // if the client sent too much data it . tooMuchData () } Earlier available commands are: From \u00b6 Listen to the MAIL FROM command (called first, can only be called once): fromListener { // get the envelope from it . envelopeFrom } Recipients \u00b6 Listen to the RCPT TO command (can be called multiple times): recipientListener { // current envelope data it . envelopeFrom it . currentRecipients // all recipients known so far (including the one responsible for this call) // get the recipient responsible for this call it . recipient } Reject Connections \u00b6 You can reject connections after receiving any command. Both functions have parameters for a custom reponse and status code. // reject the connection it . reject () // drop the connection it . dropConnection () MessageContext \u00b6 The context gives you more information about the current connection. // get the MessageContext it . context // get the session it . context . session // example usage of session it . context . session ?. socket is SSLSocket","title":"Server (receive)"},{"location":"server/#smtp-server","text":"This SMTP server can be used to receive emails.","title":"SMTP Server"},{"location":"server/#setup","text":"To set up a new SMTP server you can use the smtpServer function. val smtpServer = smtpServer ( port = 25 ) { // access the SMTP server builder in here (more information below) } Now you can start the SMTPServer // this function does not block, // but it keeps the current thread alive until you call stop() smtpServer . start () It is good practice to stop the SMTPServer smtpServer . stop () The following code samples all are inside an SMTP server builder.","title":"Setup"},{"location":"server/#optional-configuration","text":"","title":"Optional Configuration"},{"location":"server/#configuration-variables","text":"Inside the SMTP server builder, you have access to the following configuration variables: Option Description maxRecipients The maximum amount of recipients the server accepts per message. default = 1000 maxConnections The maximum amount of connections the server allows at once. default = 1000 prefferedMaxMessageSize The maximum size of a message. This won't be enforced, this is just an information for the connected client. default = null (no limit) connectionTimeout The timeout for waiting for data on a connection. default = 1 to TimeUnit.MINUTES (1 minute) The best way to set this is the following connectionTimeout = 2 to TimeUnit . MINUTES","title":"Configuration variables"},{"location":"server/#tls-secure-connections","text":"Go to the dedicated TLS page for more details.","title":"TLS (Secure connections)"},{"location":"server/#listeners","text":"With listeners, you can receive and process emails .","title":"Listeners"},{"location":"server/#commands","text":"","title":"Commands"},{"location":"server/#mail-easiest","text":"Listen to the DATA command (called last, therefore has the most information): mailListener { // get envelope data it . envelopeFrom it . recipients // get the email it . email // optional response it . respondText ( \"OK message received\" ) // if the client sent too much data it . tooMuchData () } Earlier available commands are:","title":"Mail (easiest)"},{"location":"server/#from","text":"Listen to the MAIL FROM command (called first, can only be called once): fromListener { // get the envelope from it . envelopeFrom }","title":"From"},{"location":"server/#recipients","text":"Listen to the RCPT TO command (can be called multiple times): recipientListener { // current envelope data it . envelopeFrom it . currentRecipients // all recipients known so far (including the one responsible for this call) // get the recipient responsible for this call it . recipient }","title":"Recipients"},{"location":"server/#reject-connections","text":"You can reject connections after receiving any command. Both functions have parameters for a custom reponse and status code. // reject the connection it . reject () // drop the connection it . dropConnection ()","title":"Reject Connections"},{"location":"server/#messagecontext","text":"The context gives you more information about the current connection. // get the MessageContext it . context // get the session it . context . session // example usage of session it . context . session ?. socket is SSLSocket","title":"MessageContext"},{"location":"setup_gradle/","text":"Setup \u00b6 Repository \u00b6 SimpleKotlinMail is available on Maven Central. repositories { mavenCentral () } Dependencies \u00b6 Kotlin DSL dependencies { implementation ( \"net.axay:MODULE:VERSION\" ) } or Groovy DSL dependencies { implementation 'net.axay:MODULE:VERSION' } Replace : VERSION with the version you wish to use (you can find the latest version on github ) MODULE with the names of the following modules: Modules \u00b6 simplekotlinmail-core (required) simplekotlinmail-client if you want to send emails simplekotlinmail-server if you want to receive emails simplekotlinmail-html if you want to use kotlinx.html inside your email builders JVM Version \u00b6 To be able to use the inline functions of the API, you have to configure the JVM version (if you have not done that already). tasks . withType < KotlinCompile > { kotlinOptions . jvmTarget = jvmVersionString // <- e.g. 11 }","title":"Setup using Gradle"},{"location":"setup_gradle/#setup","text":"","title":"Setup"},{"location":"setup_gradle/#repository","text":"SimpleKotlinMail is available on Maven Central. repositories { mavenCentral () }","title":"Repository"},{"location":"setup_gradle/#dependencies","text":"Kotlin DSL dependencies { implementation ( \"net.axay:MODULE:VERSION\" ) } or Groovy DSL dependencies { implementation 'net.axay:MODULE:VERSION' } Replace : VERSION with the version you wish to use (you can find the latest version on github ) MODULE with the names of the following modules:","title":"Dependencies"},{"location":"setup_gradle/#modules","text":"simplekotlinmail-core (required) simplekotlinmail-client if you want to send emails simplekotlinmail-server if you want to receive emails simplekotlinmail-html if you want to use kotlinx.html inside your email builders","title":"Modules"},{"location":"setup_gradle/#jvm-version","text":"To be able to use the inline functions of the API, you have to configure the JVM version (if you have not done that already). tasks . withType < KotlinCompile > { kotlinOptions . jvmTarget = jvmVersionString // <- e.g. 11 }","title":"JVM Version"},{"location":"setup_maven/","text":"Setup (Maven) \u00b6 Currently, there is no setup guide for Maven. For the repository and dependencies, you can have a look at the Gradle setup guide (or switch to Gradle entirely).","title":"Setup using Maven"},{"location":"setup_maven/#setup-maven","text":"Currently, there is no setup guide for Maven. For the repository and dependencies, you can have a look at the Gradle setup guide (or switch to Gradle entirely).","title":"Setup (Maven)"},{"location":"tls/","text":"TLS \u00b6 TLS ( Transport Layer Security ) allows you to secure the Simple Mail Transfer Protocol. You probably want to let your proxy handle TLS , this guide is for TLS in tests. TLSContext (SSLContext) \u00b6 SimpleKotlinMail provides a utility function allowing you to easily create a new TLSContext (actually an SSLContext). val tlsContext = TLSContext ( File ( \"path/to/keystore\" ), keyStorePassphrase = \"passphrase\" , File ( \"path/to/truststore\" ), trustStorePassphrase = \"passphrase\" ) If you need a keystore and truststore for testing purposes , you can download both from the OpenJDK repository . Secure the SMTP server \u00b6 Use the setupTLS function inside an SMTP server builder. smtpServer { setupTLS ( tlsContext ) } Currently, TLSv1.3 and TLSv1.2 are enabled by default, but you can change that (example below). or if you need more options setupTLS ( tlsContext , requireTLS = true , protocolVersions = listOf ( TLSVersions . TLS_1_3 ), requireClientAuth = true ) { // configure the SSLSocket to your liking } Secure the Mailer \u00b6 Inside a mailer builder, you can set the transport strategy: mailerBuilder { // STARTTLS withTransportStrategy ( TransportStrategy . SMTP_TLS ) // or complete TLS encryption withTransportStrategy ( TransportStrategy . SMTPS ) }","title":"TLS"},{"location":"tls/#tls","text":"TLS ( Transport Layer Security ) allows you to secure the Simple Mail Transfer Protocol. You probably want to let your proxy handle TLS , this guide is for TLS in tests.","title":"TLS"},{"location":"tls/#tlscontext-sslcontext","text":"SimpleKotlinMail provides a utility function allowing you to easily create a new TLSContext (actually an SSLContext). val tlsContext = TLSContext ( File ( \"path/to/keystore\" ), keyStorePassphrase = \"passphrase\" , File ( \"path/to/truststore\" ), trustStorePassphrase = \"passphrase\" ) If you need a keystore and truststore for testing purposes , you can download both from the OpenJDK repository .","title":"TLSContext (SSLContext)"},{"location":"tls/#secure-the-smtp-server","text":"Use the setupTLS function inside an SMTP server builder. smtpServer { setupTLS ( tlsContext ) } Currently, TLSv1.3 and TLSv1.2 are enabled by default, but you can change that (example below). or if you need more options setupTLS ( tlsContext , requireTLS = true , protocolVersions = listOf ( TLSVersions . TLS_1_3 ), requireClientAuth = true ) { // configure the SSLSocket to your liking }","title":"Secure the SMTP server"},{"location":"tls/#secure-the-mailer","text":"Inside a mailer builder, you can set the transport strategy: mailerBuilder { // STARTTLS withTransportStrategy ( TransportStrategy . SMTP_TLS ) // or complete TLS encryption withTransportStrategy ( TransportStrategy . SMTPS ) }","title":"Secure the Mailer"}]}